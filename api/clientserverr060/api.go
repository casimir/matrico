// This file is generated and not meant to be edited by hand."

package clientserverr060

import (
	"net/http"

	"github.com/casimir/matrico/api/common"
	"github.com/go-chi/chi"
)

func Register(r chi.Router) {
	r.Get("/_matrix/client/r0/login", GetLoginFlows)
	r.Post("/_matrix/client/r0/login", Login)
	r.Get("/_matrix/client/versions", GetVersions)
	r.Route("/", func(r chi.Router) {
		r.Use(common.AuthorizationMiddleware)
		r.Post("/_matrix/client/r0/user/{userId}/filter", DefineFilter)
		r.Post("/_matrix/client/r0/logout", Logout)
		r.Get("/_matrix/client/r0/pushrules/", GetPushRules)
		r.Get("/_matrix/client/r0/sync", Sync)
	})
}

type DefineFilterBody map[string]interface{}

type DefineFilterResponse struct {
	// The ID of the filter that was created. Cannot start
	// with a ``{`` as this character is used to determine
	// if the filter provided is inline JSON or a previously
	// declared filter by homeservers on some APIs.
	FilterID string `json:"filter_id"`
}

// Uploads a new filter definition to the homeserver.
// Returns a filter ID that may be used in future requests to
// restrict which events are returned to the client.
func DefineFilter(w http.ResponseWriter, r *http.Request) {
	userId := chi.URLParam(r, "userId")
	var body DefineFilterBody
	if err := common.UnmarshalBody(r, &body); err != nil {
		common.ResponseHandler(w, nil, err)
		return
	}
	data, err := defineFilter(userId, body)
	common.ResponseHandler(w, data, err)
}

type GetLoginFlowsResponseFlows struct {
	// The login type. This is supplied as the ``type`` when
	// logging in.
	Type string `json:"type,omitempty"`
}

type GetLoginFlowsResponse struct {
	// The homeserver's supported login types
	Flows []GetLoginFlowsResponseFlows `json:"flows,omitempty"`
}

// Gets the homeserver's supported login types to authenticate users. Clients
// should pick one of these and supply it as the ``type`` when logging in.
func GetLoginFlows(w http.ResponseWriter, r *http.Request) {
	data, err := getLoginFlows()
	common.ResponseHandler(w, data, err)
}

type LoginBody struct {
	// Third party identifier for the user.  Deprecated in favour of ``identifier``.
	Address string `json:"address,omitempty"`
	// ID of the client device. If this does not correspond to a
	// known client device, a new device will be created. The server
	// will auto-generate a device_id if this is not specified.
	DeviceID string `json:"device_id,omitempty"`
	// Identification information for the user.
	Identifier map[string]interface{} `json:"identifier,omitempty"`
	// A display name to assign to the newly-created device. Ignored
	// if ``device_id`` corresponds to a known device.
	InitialDeviceDisplayName string `json:"initial_device_display_name,omitempty"`
	// When logging in using a third party identifier, the medium of the identifier. Must be 'email'.  Deprecated in favour of ``identifier``.
	Medium string `json:"medium,omitempty"`
	// Required when ``type`` is ``m.login.password``. The user's
	// password.
	Password string `json:"password,omitempty"`
	// Required when ``type`` is ``m.login.token``. Part of `Token-based`_ login.
	Token string `json:"token,omitempty"`
	// The login type being used.
	Type string `json:"type"`
	// The fully qualified user ID or just local part of the user ID, to log in.  Deprecated in favour of ``identifier``.
	User string `json:"user,omitempty"`
}

type LoginResponse struct {
	// An access token for the account.
	// This access token can then be used to authorize other requests.
	AccessToken string `json:"access_token,omitempty"`
	// ID of the logged-in device. Will be the same as the
	// corresponding parameter in the request, if one was specified.
	DeviceID string `json:"device_id,omitempty"`
	// The server_name of the homeserver on which the account has
	// been registered.
	//
	// **Deprecated**. Clients should extract the server_name from
	// ``user_id`` (by splitting at the first colon) if they require
	// it. Note also that ``homeserver`` is not spelt this way.
	HomeServer string `json:"home_server,omitempty"`
	// The fully-qualified Matrix ID that has been registered.
	UserID string `json:"user_id,omitempty"`
	// Optional client configuration provided by the server. If present,
	// clients SHOULD use the provided object to reconfigure themselves,
	// optionally validating the URLs within. This object takes the same
	// form as the one returned from .well-known autodiscovery.
	WellKnown map[string]interface{} `json:"well_known,omitempty"`
}

// Authenticates the user, and issues an access token they can
// use to authorize themself in subsequent requests.
//
// If the client does not supply a ``device_id``, the server must
// auto-generate one.
//
// The returned access token must be associated with the ``device_id``
// supplied by the client or generated by the server. The server may
// invalidate any access token previously associated with that device. See
// `Relationship between access tokens and devices`_.
func Login(w http.ResponseWriter, r *http.Request) {
	var body LoginBody
	if err := common.UnmarshalBody(r, &body); err != nil {
		common.ResponseHandler(w, nil, err)
		return
	}
	data, err := login(body)
	common.ResponseHandler(w, data, err)
}

type LogoutResponse map[string]interface{}

// Invalidates an existing access token, so that it can no longer be used for
// authorization. The device associated with the access token is also deleted.
// `Device keys <#device-keys>`_ for the device are deleted alongside the device.
func Logout(w http.ResponseWriter, r *http.Request) {
	data, err := logout()
	common.ResponseHandler(w, data, err)
}

type GetPushRulesResponseGlobal map[string]interface{}

type GetPushRulesResponse struct {
	// The global ruleset.
	Global GetPushRulesResponseGlobal `json:"global"`
}

// Retrieve all push rulesets for this user. Clients can "drill-down" on
// the rulesets by suffixing a ``scope`` to this path e.g.
// ``/pushrules/global/``. This will return a subset of this data under the
// specified key e.g. the ``global`` key.
func GetPushRules(w http.ResponseWriter, r *http.Request) {
	data, err := getPushRules()
	common.ResponseHandler(w, data, err)
}

type SyncResponseAccountData map[string]interface{}

type SyncResponseDeviceLists map[string]interface{}

type SyncResponsePresence map[string]interface{}

type SyncResponseRooms struct {
	// The rooms that the user has been invited to, mapped as room ID to
	// room information.
	Invite map[string]interface{} `json:"invite,omitempty"`
	// The rooms that the user has joined, mapped as room ID to
	// room information.
	Join map[string]interface{} `json:"join,omitempty"`
	// The rooms that the user has left or been banned from, mapped as room ID to
	// room information.
	Leave map[string]interface{} `json:"leave,omitempty"`
}

type SyncResponseToDevice map[string]interface{}

type SyncResponse struct {
	// The global private data created by this user.
	AccountData SyncResponseAccountData `json:"account_data,omitempty"`
	// Information on end-to-end device updates, as specified in
	// |device_lists_sync|_.
	DeviceLists SyncResponseDeviceLists `json:"device_lists,omitempty"`
	// Information on end-to-end encryption keys, as specified
	// in |device_lists_sync|_.
	DeviceOneTimeKeysCount map[string]int `json:"device_one_time_keys_count,omitempty"`
	// The batch token to supply in the ``since`` param of the next
	// ``/sync`` request.
	NextBatch string `json:"next_batch"`
	// The updates to the presence status of other users.
	Presence SyncResponsePresence `json:"presence,omitempty"`
	// Updates to rooms.
	Rooms SyncResponseRooms `json:"rooms,omitempty"`
	// Information on the send-to-device messages for the client
	// device, as defined in |send_to_device_sync|_.
	ToDevice SyncResponseToDevice `json:"to_device,omitempty"`
}

// Synchronise the client's state with the latest state on the server.
// Clients use this API when they first log in to get an initial snapshot
// of the state on the server, and then continue to call this API to get
// incremental deltas to the state, and to receive new messages.
//
// *Note*: This endpoint supports lazy-loading. See `Filtering <#filtering>`_
// for more information. Lazy-loading members is only supported on a ``StateFilter``
// for this endpoint. When lazy-loading is enabled, servers MUST include the
// syncing user's own membership event when they join a room, or when the
// full state of rooms is requested, to aid discovering the user's avatar &
// displayname.
//
// Like other members, the user's own membership event is eligible
// for being considered redundant by the server. When a sync is ``limited``,
// the server MUST return membership events for events in the gap
// (between ``since`` and the start of the returned timeline), regardless
// as to whether or not they are redundant.  This ensures that joins/leaves
// and profile changes which occur during the gap are not lost.
func Sync(w http.ResponseWriter, r *http.Request) {
	data, err := sync(r.URL.Query())
	common.ResponseHandler(w, data, err)
}

type GetVersionsResponse struct {
	// Experimental features the server supports. Features not listed here,
	// or the lack of this property all together, indicate that a feature is
	// not supported.
	UnstableFeatures map[string]bool `json:"unstable_features,omitempty"`
	// The supported versions.
	Versions []string `json:"versions"`
}

// Gets the versions of the specification supported by the server.
//
// Values will take the form ``rX.Y.Z``.
//
// Only the latest ``Z`` value will be reported for each supported ``X.Y`` value.
// i.e. if the server implements ``r0.0.0``, ``r0.0.1``, and ``r1.2.0``, it will report ``r0.0.1`` and ``r1.2.0``.
//
// The server may additionally advertise experimental features it supports
// through ``unstable_features``. These features should be namespaced and
// may optionally include version information within their name if desired.
// Features listed here are not for optionally toggling parts of the Matrix
// specification and should only be used to advertise support for a feature
// which has not yet landed in the spec. For example, a feature currently
// undergoing the proposal process may appear here and eventually be taken
// off this list once the feature lands in the spec and the server deems it
// reasonable to do so. Servers may wish to keep advertising features here
// after they've been released into the spec to give clients a chance to
// upgrade appropriately. Additionally, clients should avoid using unstable
// features in their stable releases.
func GetVersions(w http.ResponseWriter, r *http.Request) {
	data, err := getVersions()
	common.ResponseHandler(w, data, err)
}
